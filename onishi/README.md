
# 1章 TypeScriptとは何か

## 項目1: TypeScriptとJavaScriptの関係を理解する

  型チェック厳しいのかと思ったら文字列と数値の結合許してるのちょっと意外

## 項目2: どのTypeScriptオプションが使われているか把握する

- `tsconfig.json`は`jsonc`なのでコメントを入れられる
- インデックスアクセス時の暗黙的anyは`suppressImplicitAnyIndexErrors`で抑制できる。が影響範囲が大きいため、`@ts-ignore`が推奨されている。
  [リンク](https://www.typescriptlang.org/ja/tsconfig/#suppressImplicitAnyIndexErrors)

- 型推論ややこしそう。

  ```typeScript
  const list = {
    keyA: 1.0,
    keyB: 0.5,
    keyC: 0.3
  };

  const key = 'keyA';   // こっちはエラーが出ない
  const key:string = 'keyA'; // こっちはエラーが出る

  console.log(list[key]);
  ```

- `strictNullChecks`を設定すると実装難易度が上がるらしい。いまいちイメージできない。

- `noUncheckedIndexedAccess`は便利そうだけど邪魔に感じることも多そう。

## 項目3: コード生成は型に依存しないことを理解する

- 実行時にはjavascriptに変換されているので型チェックは行われないし、(実行時の)パフォーマンスにも影響しない

## 項目4: 構造的型付けに慣れる

- 構造的型付けは便利そうだけどコード読むときに混乱しそう

  ``` typescript
  // りんごの型
  interface Apple {
    color: string;
    size: number;
  }

  // みかんの型（名前は違うけど中身は同じ）
  interface Orange {
    color: string;
    size: number;
  }

  function printFruit(fruit: Apple) {
    console.log(`色: ${fruit.color}, サイズ: ${fruit.size}`);
  }

  const myOrange: Orange = { color: "orange", size: 5 };

  // Orange型だけど、Apple型として使える！
  printFruit(myOrange); // OK！
  ```

## 項目5: any型の使用を制限する

- そもそもany型を使いたくなるタイミングがよくわからない

# 2章 TypeScriptの型システム

## 項目6: エディターを使って型システムを調査、探求する

- 条件分岐の中で型が変化した場合に確認できるのすごく便利そう。と思ったらPHPでもできた。

## 項目7: 型を値の集合として考える

- リテラル型のメリットがよくわからん。
  - ユニオンにするのが便利そうだけどenumでいいんじゃないのかな
- &演算子を用いると両方の型を同時に満たす型を作る
- |演算子を用いると両方の型のうち少なくとも片方を満たす型を作る

## 項目8: 型空間のシンボルと値空間のシンボルの見分け方を知る

- 型空間 → トランスパイルすると消える。値空間 → トランスパイルしても消えない
  - 実装の上ではあまり意識しなくて良さそうに思えたけどどうなんだろう。

## 項目9: 型アノテーションを型アサーションより優先的に使用する

- 基本はアサーションよりもアノテーションを使うべき。
  - 開発者が型についての情報をtsよりも多く知っているならばアサーションを使うのもあり。
    ただしその場合はコメントにて注釈を付すべき。
- アサーションをキャストと呼ぶことがあるがtsにおいては値変換を含まないので不適。

## 項目10: ラッパーオブジェクト型（String、Number、Boolean、Symbol、BigInt）を使用しない

- ラッパーオブジェクトを使うミス、タイポとかでうっかりやってしまいそう。

  ```typeScript
  const foo1:string = "abc"         // プリミティブ
  const foo2 = String("abc")        // プリミティブ いわゆるキャストがこれ
  const foo3 = new String("abc")    // ラッパーオブジェクト
  ```

## 項目11: 余剰プロパティチェックと型チェックを区別する

- このへんよくわかってないとエラーを潰すことだけを目的とした変な小手先の技術だけ覚えてしまいそう。

## 項目12: 可能なら関数式全体に型を適用する

- 関数をラップしたいときは結構ありそうだしそれを型維持したままできるのは便利そう。

## 項目13: type（型エイリアス）とinterfaceの違いを知る

- 宣言のマージにびっくりした。同名で宣言してエラー吐かないの、直感に反してる。
- typeのほうができること多いし良さげだと思ったんだけどinterface推しらしい。
  - 「型名はエラーメッセージや型の表示で一貫して使われるようになり」というのがよくわからなかった
  - 下記のコード(GPTに書いてもらった)で前者は`UserI`が表示されているが後者は`UserT`が表示されていないという話？

  ```typeScript
  // --- interface 版 ---
  interface UserI {
    id: number
    name: string
  }

  const ui: UserI = { id: 1 }
  // ↓ tsc の出力例（TS2741）:
  // Property 'name' is missing in type '{ id: number; }'
  //   but required in type 'UserI'.



  // --- type alias 版（交差型） ---
  type UserT = { id: number } & { name: string }

  const ut: UserT = { id: 1 }
  // ↓ tsc の出力例（TS2741）:
  // Property 'name' is missing in type '{ id: number; }'
  //   but required in type '{ id: number; } & { name: string; }'.
  ```

## 項目14: readonlyを使用して変更にまつわるエラーを避ける

- readonlyはつけまくったほうがいいんだろうけど徹底は難しそう
  - eslintの設定で縛れるみたいだけど関数内で本当に変更されていないかまでは読み取ってくれてなさそう

## 項目15: 型演算とジェネリック型を使って重複を避ける

- テクニック色々書いてあったけど暗記はきついので「こんなのあった気がする」とだけ覚えておく
- dryのやり過ぎはあるある。コードの見た目ではなく意味で考えるべき

## 項目16: インデックスシグネチャよりも適切な代替手段を使う

- (本の論調ではあまり使うなという話だったが)インデックスシグネチャが以下のケースで機能するのは便利そうだなと思った。

  ```typeScript
  interface WebComponentProps {
    [key: `data-${string}`]: string;
  }
  //  OK："data-"で始まるキー
  const validProps: WebComponentProps = {
    'data-user-id': '123',
    'data-role': 'admin',
  };
  //  NG："aria-"や"foo"は型エラーになる
  const invalidProps: WebComponentProps = {
    'aria-label': 'Close', //  型エラー！
    'foo': 'bar',          //  型エラー！
    'data-valid': 'yes',   //  OK
  };
  ```

## 項目17: 数値型のインデックスシグネチャを避ける

- 「複雑なオブジェクトをキーとして使おうとすると、そのオブジェクトのtoStringメソッドが呼び出すされて文字列に変換されます。」
  - これ知らないと沼りそう。
- mapならキーにオブジェクトを指定可能

# 3章 型推論と制御フロー解析

## 項目18: 推論可能な型でコードを乱雑にしない

- 自明な型アノテーションは書かない。
  - 単にコード量が減るだけではなく仕様変更時の修正箇所が減る。
  - C言語みたいなタイプで「idに文字列も含むようにします」って変更が入ったら大変そう
- 戻り値の型アノテーションをつけるのは複数のreturn文を持つ関数において特に有用

## 項目19: 異なる型には異なる変数を使う

## 項目20: 変数の型がどのように決まるか理解する

## 項目21: オブジェクトを一度に構築する

## 項目22: 型の絞り込みを理解する

## 項目23: エイリアスを作成したら一貫してそれを使う

## 項目24: 型推論に文脈がどう使われるか理解する

## 項目25: 進化する型を理解する

## 項目26: 関数型の標準APIやライブラリを使って型の流れを促進する

## 項目27: コールバックの代わりにasync関数を使用して型の流れを改善する

## 項目28: クラスやカリー化を使って型パラメーターを段階的に割り当てる

# 4章 型設計

## 項目29: 有効な状態のみ表現する型を作る

## 項目30: 入力には寛容に、出力には厳格に

## 項目31: 型情報をドキュメントで繰り返さない

## 項目32: nullやundefinedを型エイリアスに含めない

## 項目33: null値を型の外側に押しやる

## 項目34: ユニオンを含むインターフェイスよりも、インターフェイスのユニオンを選択する

## 項目35: stringよりもそれに代わる、より精度の高い型を選択する

## 項目36: 特別な値には専用の型を使用する

## 項目37: オプションプロパティは限定的に使用する

## 項目38: 同じ型のパラメーターの繰り返しを避ける

## 項目39: 差異のモデリングより型の統一を優先する

## 項目40: 正確でない型より精度の低い型を選択する

## 項目41: ドメインの言語を使って型を命名する

## 項目42: たまたま目にしたデータに基づく型を避ける

# 5章 不健全性とany型

## 項目43: 可能なかぎり狭いスコープでany型を使う

## 項目44: anyをそのまま使うのではなく、より具体的な形式で使う

## 項目45: 安全でない型アサーションを、適切に型付けされた関数の内部に隠す

## 項目46: 型が不明な値には、anyではなくunknownを使う

## 項目47: モンキーパッチではなく、より型安全なアプローチを採用する

## 項目48: 健全性の罠を回避する

## 項目49: 型カバレッジを監視し、型安全性のリグレッションを防ぐ

# 6章 ジェネリックと型レベルプログラミング

## 項目50: ジェネリックを型に対する関数と考える

## 項目51: 不必要な型パラメーターを避ける

## 項目52: オーバーロードシグネチャより条件型を優先的に使用する

## 項目53: 条件型のユニオンでの分配を制御する

## 項目54: テンプレートリテラル型を使ってDSLや文字列間の関係をモデリングする

## 項目55: 型のテストを書く

## 項目56: 型の表示に配慮する

## 項目57: 再帰的なジェネリック型は末尾再帰にする

## 項目58: コード生成を複雑な型の代替手段として検討する

# 7章 TypeScriptレシピ集

## 項目59: never型を使って網羅性チェックを行う

## 項目60: オブジェクトに対して反復処理する方法を知る

## 項目61: Record型を使って値の同期を保つ

## 項目62: レストパラメーターとタプル型を使って、可変長引数の関数をモデリングする

## 項目63: never型のオプションプロパティを使って、排他的論理和をモデリングする

## 項目64: 名前的型付けのためにブランドを使うことを検討する

# 8章 型宣言と@types

## 項目65: TypeScriptと@typesはdevDependenciesに追加する

## 項目66: 型宣言の依存関係に関わる3つのバージョンを理解する

## 項目67: パブリックなAPIで使われるすべての型をエクスポートする

## 項目68: APIのコメントにTSDocを使う

## 項目69: コールバックのthisがAPIの一部なら、それに型を与える

## 項目70: 型を部分的にコピーして依存を断ち切る

## 項目71: モジュールオーグメンテーションを使って型を改善する

# 9章 コードを書いて実行する

## 項目72: TypeScriptの独自機能の使用を避け、ECMAScriptの機能を使う

## 項目73: ソースマップを使ってTypeScriptをデバッグする

## 項目74: 実行時に型を再構築する方法を知る

## 項目75: DOMの型階層を理解する

## 項目76: ターゲットとする環境の正確なモデルを作る

## 項目77: 型チェックとユニットテストの関係を理解する

## 項目78: コンパイラーのパフォーマンスに注意を払う

# 10章 コードのモダン化とTypeScriptへの移行

## 項目79: モダンなJavaScriptを書く

## 項目80: @ts-checkとJSDocを使ってTypeScriptを試す

## 項目81: allowJsを使ってTypeScriptとJavaScriptを共存させる

## 項目82: 依存関係グラフの下から上へモジュールごとに移行する

## 項目83: noImplicitAnyを有効にするまで、移行が完了したと考えない

# 付録

## 付録A 初版の項目とのマッピング

## 付録B 推奨事項の実践法

## 項目84: コンパイラーオプションやリンターを使ってコードに規約を適用する

## md がどう見えるかテスト

### 太字の例

## **これは太字です**

### 折りたたみの例

<details>
<summary>クリックして展開</summary>

折りたたまれた内容がここに表示されます。

</details>

### リンクの例

## [Google](https://www.google.com)

### 箇条書きの例

## リスト 1

## リスト 2

## サブリスト 1

## サブリスト 2

### 番号付きリストの例

1. 番号 1
2. 番号 2
3. サブ番号 1
4. サブ番号 2

### コードブロックの例

```javascript
function helloWorld() {
  console.log("Hello, World!");
}
```

### 引用の例

> これは引用です。

### 表の例

| 見出し 1 | 見出し 2 |
| -------## | -------## |
| 内容 1   | 内容 2   |
| 内容 3   | 内容 4   |
