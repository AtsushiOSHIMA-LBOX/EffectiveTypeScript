# 5章 不健全性とany型

anyはダメだという論調だったのにここにきて急に有用性を主張しだした。チートデーもたまにはいるよねみたいな雰囲気。

実用上、理想と現実にはギャップがあるので、軟着陸させる方法を身につける必要がある。

### 項目43

anyの影響は最小限に収まるように工夫する（anyの伝染性）。型アノテーション（特に戻り値）は有効な方法足りうる。

`ReturnType`を使う解決法もあり。

```TypeScript
function eatDinner3() {
    const pizza = getPizza();
    // @ts-ignore
    eatSalad(pizza as Salad);
    pizza.slice();
}
```

このケースなら、これが一番いいだろう。

### 項目44

`any` より `any[]` ！　`any[]` より `unknown[]` ！

レストパラメーター=可変長引数。でも、可変長引数でstringとnumberが混ざったりすることあるか？？

### 項目45

型シグネチャって何？？？

p208。どのみち悪い例だけど…

```TypeScript
type promise1 = Promise<MountainPeak>; // きれい

type promise2 = Promise<unknown>; // 意味ある
type promise3 = Promise<MountainPeak|unknown>; // 意味ない（型の拡大より）
```

項目9。TypeScriptよりも人間の方が型について詳しいときなので、型アサーションが使える。

影響範囲が最小になるようにリファクタリングをする。そしてそれができるのがTypeScript。ブラックボックステストを意識。

責任の取り方はコミュニケーション（属人化）ではない。

### 項目46

unknown

- 全ての型が代入可能
- unknownはunknownにしか代入できない

never

- 全ての型が代入不可能
- neverは全ての型に代入できる

### 項目47

使われがちなモンキーパッチは避けるべき。ただ、実際に対応するのは難しい。

### 項目48

### 項目49

定量化すること（定量化されていない→定量化されているにすること）は大事。ただ定量化されているを目標化してしまうとよくない？　←この問題は技術の進歩である程度解消された？
