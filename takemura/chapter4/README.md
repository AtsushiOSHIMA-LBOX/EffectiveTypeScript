# 4章 型設計

## 項目29

理想的にはこうあるべきだが、実際に設計するときにこのような設計を思いつける自信はない。

少し例が悪く、fetchのような処理では、実際にはfetchを行うミドルウェアの仕様に設計が大きく影響される。

[エールフランス447便墜落事故](https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%BC%E3%83%AB%E3%83%95%E3%83%A9%E3%83%B3%E3%82%B9447%E4%BE%BF%E5%A2%9C%E8%90%BD%E4%BA%8B%E6%95%85)のケースは怖い。

```TypeScript
function getStickSetting(controls: CockpitControls) {
    return (controls.leftSideStick + controls.rightSideStick) / 2;
}
```

このコードをレビューで落とせないチームは山ほどあるだろう。自分も自信がない。

## 項目30

実装者間で連携ができる場合、書いてある通りではなく明らかに入力も厳格にした方が良い。

連携ができなくて寛容にせざるを得ない場合でも、Adaptorパターンを用いる対処法を考え、ファイルレベルで責務を区切って処理すべき。

ユーザーが直接入力するCLIコマンドなどでは、寛容にした方がいい場合もある（昔はそういうトレンドだったが、今もそうかは不明）。`tar`のオプションを常に正確に打てますか？

## 項目31

よりドメイン（言語仕様）に近い実現方法があるならそちらを採用すべき。属人性も減るので。

コメントにはwhatではなくwhyを書くという理念にも通じる。

ファイルサイズなども単位をつけよう！

## 項目32

結局対策として挙げられた `NullableUser` もバッドプラクティスとして考えてよい。

## 項目33

訳注3賢すぎる。

```TypeScript
const numArray: [number, ...number[]] = [0, 1];
const numArray2: [number, ...number[]] = []; // NG
```

エレガントな書き方であるが、**実行時は空配列でも動いちゃうので**、本当に塞ぎたいときはガード節を書かなければならない。

意味のある値の組をセットで扱う。`[min, max]` 競プロで罠にはめられそう。

## 項目34

意外と面倒になって見落としがち。バリデーションももっと組合せによってやることを考えたほうがいいかも。

組合せ爆発を起こすような設計をすると、当然意図せぬバグが混入する確率が上がりますよ～という話と認識。

タグみたいなあまり意味のなさそうなデータは別に追加しても良い（当然上のような取り組みをした上で）。これで認識してくれるからtslintは賢い。

## 項目35

配列のキーを外側から指定するときstringにして破滅するのは本当にありがちなケースなんだけど、よくない。よくないが、この問題に対応するにはかなり難しいということも分かった（対応可能ではある）。

無限集合をモデリングできる方が嬉しさがあるかも（項目54）

## 項目36

ラップしたらいいのは分かるけど、そこまでやるならオーバーライドもサポートしてほしい（ts-compilerの都合上無理なのはわかるが…）。一応静的解析のルールで対応可能か？

strictNullCheckをオフにしないとnullやundefinedを明示的に使いたいときに仕えない。一方で、strictNullCheckをオフにするのはより悪い状態を招く。ジレンマがある。適切なコードレビューが必須。

```typescript
type Product = ValuedProduct | UnvaluedProduct;

interface ValuedProduct {
    title: string;
    priceDollars: number;
}

interface UnvaluedProduct {
    title: string;
}
```

まあ、多分こっちのほうが本質的にいいんだと思う。(項目29)

## 項目37

オプションプロパティはnullと同じような欠陥がある。オプションプロパティをどうしても使わなければいけないときは、オプションプロパティを使っていない型と同時に宣言して変換する。

## 項目38

引数には単一のオブジェクトより複数のオブジェクトの方がいいかなとなんとなく思っていたが（ReactのPropsパターンがそんなにイケてると思っていないので）本では優劣をつけていなかった。

## 項目39

これは逆じゃないか？　DBに登録したりバックエンドに送信する段階でミドルウェアで `Record<string, string>` のように（これは良くないけど）変換したほうがいいような。

Remixのようなtsで全て完結するフレームワークのような存在を強く仮定している項目に感じる。

変換を経由しないと一部のデータが消えてしまう。それはそうだが、気づきにくいバグになりうる。

## 項目40

一度間違えて公開してしまったAPIは変更せず最後まで責任を持つ。

型を厳密にすることを目的にしない。

## 項目41

英語力の問題があるかもしれない？

粒度の問題。ただし、途中でいきなり全部変えるわけにはいかないのが悩ましい。

変数名は長くなりすぎるくらいがちょうどいいかもしれない。

## 項目42

外部ライブラリを使うときにはさほど問題は出なさそう（デフォルトでサポートされているケースも多い）。問題は自分でAPIを設計するとき。どういうケースで漏れがあるかをチェックする方法が本では書いてないので（スキーマを定義して漏れを確認しろとあるがスキーマ自体に漏れがあったら？）、そういう時に困る。えてしてアジャイルだとそういう現象が起きがちなため。
