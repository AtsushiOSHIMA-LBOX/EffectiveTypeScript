# 4章 型設計

## 項目29

理想的にはこうあるべきだが、実際に設計するときにこのような設計を思いつける自信はない。

少し例が悪く、fetchのような処理では、実際にはfetchを行うミドルウェアの仕様に設計が大きく影響される。

[エールフランス447便墜落事故](https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%BC%E3%83%AB%E3%83%95%E3%83%A9%E3%83%B3%E3%82%B9447%E4%BE%BF%E5%A2%9C%E8%90%BD%E4%BA%8B%E6%95%85)のケースは怖い。

```TypeScript
function getStickSetting(controls: CockpitControls) {
    return (controls.leftSideStick + controls.rightSideStick) / 2;
}
```

このコードをレビューで落とせないチームは山ほどあるだろう。自分も自信がない。

## 項目30

実装者間で連携ができる場合、書いてある通りではなく明らかに入力も厳格にした方が良い。

連携ができなくて寛容にせざるを得ない場合でも、Adaptorパターンを用いる対処法を考え、ファイルレベルで責務を区切って処理すべき。

ユーザーが直接入力するCLIコマンドなどでは、寛容にした方がいい場合もある（昔はそういうトレンドだったが、今もそうかは不明）。`tar`のオプションを常に正確に打てますか？

## 項目31

よりドメイン（言語仕様）に近い実現方法があるならそちらを採用すべき。属人性も減るので。

コメントにはwhatではなくwhyを書くという理念にも通じる。

ファイルサイズなども単位をつけよう！

## 項目32

結局対策として挙げられた `NullableUser` もバッドプラクティスとして考えてよい。

## 項目33

訳注3賢すぎる。

```TypeScript
const numArray: [number, ...number[]] = [0, 1];
const numArray2: [number, ...number[]] = []; // NG
```

エレガントな書き方であるが、**実行時は空配列でも動いちゃうので**、本当に塞ぎたいときはガード節を書かなければならない。

意味のある値の組をセットで扱う。`[min, max]` 競プロで罠にはめられそう。

## 項目34

意外と面倒になって見落としがち。バリデーションももっと組合せによってやることを考えたほうがいいかも。

組合せ爆発を起こすような設計をすると、当然意図せぬバグが混入する確率が上がりますよ～という話と認識。

タグみたいなあまり意味のなさそうなデータは別に追加しても良い（当然上のような取り組みをした上で）。これで認識してくれるからtslintは賢い。

## 項目35

配列のキーを外側から指定するときstringにして破滅するのは本当にありがちなケースなんだけど、よくない。よくないが、この問題に対応するにはかなり難しいということも分かった（対応可能ではある）。

無限集合をモデリングできる方が嬉しさがあるかも（項目54）

## 項目36

## 項目37

## 項目38

## 項目39

## 項目40

## 項目41

## 項目42
